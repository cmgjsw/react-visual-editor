import { get, update } from 'lodash';
import { produce } from 'immer';
import { StateType } from '../types';
import {
	copyConfig,
	deleteChildNodes,
	deleteChildNodesKey,
	getLocation,
	getNewKey,
	HandleInfoType,
	handleRules,
	restObject,
	ROOT,
	warn,
} from '../utils';
import { LayoutSortPayload } from '../actions';

/**
 * 往画板或者容器组件添加组件
 * @param state
 * @returns {{pageConfig: *}}
 */
export function addComponent(state: StateType): StateType {
	const {
		undo,
		redo,
		pageConfig,
		dragSource,
		dropTarget,
		selectedInfo,
	} = state;
	/**
	 * 如果没有拖拽的组件不做添加动作, 如果没有
	 */
	if (!dragSource) return state;
	const { vDOMCollection, dragKey, parentKey, parentPropName } = dragSource;
	/**
	 * 如果没有root根节点，新添加的组件添加到root
	 */
	if (!pageConfig[ROOT]) {
		undo.push({ pageConfig });
		redo.length = 0;
		return {
			...state,
			pageConfig: vDOMCollection!,
			dragSource: null,
			dropTarget: null,
			undo,
			redo,
		};
	}
	const { selectedKey, propName, domTreeKeys } =
		dropTarget || selectedInfo || {};

	/**
	 * 如果有root根节点，并且即没有选中的容器组件也没有drop的目标，那么就要回退到drag目标，
	 * 添加之前的页面配置
	 */
	if (!selectedKey) {
		/**
		 * 如果有parentKey说明是拖拽的是新添加的组件，
		 * 返回原先的state状态
		 */
		if (!parentKey) {
			return { ...state, ...undo.pop(), dragSource: null };
		} else {
			return { ...state, dragSource: null };
		}
	}

	/**
	 * 当拖拽的父key与drop目标key一致说明未移动
	 * 当拖拽的key包含在drop目标的domTreeKeys,说明拖拽组件是目标组件的父组件或者是自身
	 */
	if (
		parentKey === selectedKey ||
		domTreeKeys!.includes(dragKey!) ||
		handleRules(pageConfig, dragKey!, selectedKey, propName)
	) {
		return { ...state, dragSource: null, dropTarget: null };
	}

	parentKey && undo.push({ pageConfig });
	redo.length = 0;
	return {
		...state,
		pageConfig: produce(pageConfig, (oldConfigs) => {
			//添加新组件到指定容器中
			update(oldConfigs, getLocation(selectedKey!, propName), (childNodes) => {
				return childNodes ? [...childNodes, dragKey] : [dragKey];
			});
			//如果有父key说明是跨组件的拖拽，原先的父容器需要删除该组件的引用
			if (parentKey) {
				update(oldConfigs, getLocation(parentKey), (childNodes) =>
					deleteChildNodesKey(childNodes, dragKey!, parentPropName),
				);
			}
		}),
		dragSource: null,
		dropTarget: null,
		undo,
		redo,
	};
}

/**
 * 复制组件
 * @param state
 * @returns {{pageConfig: *}}
 */
export function copyComponent(state: StateType): StateType {
	const { undo, redo, pageConfig, selectedInfo, propsConfigSheet } = state;
	/**
	 * 未选中组件不做任何操作
	 */
	if (!selectedInfo) {
		warn('Please select the node you want to copy');
		return state;
	}
	if (selectedInfo.selectedKey === ROOT) {
		warn('Prohibit copying root node');
		return state;
	}
	const { selectedKey, parentPropName, parentKey } = selectedInfo;
	const handleState: HandleInfoType = { pageConfig, propsConfigSheet };
	undo.push({ pageConfig, propsConfigSheet });
	redo.length = 0;
	const newKey = getNewKey(pageConfig);
	return {
		...state,
		...produce(handleState, (oldState) => {
			update(
				oldState.pageConfig,
				getLocation(parentKey!, parentPropName),
				(childNodes) => [...childNodes, `${newKey}`],
			);
			copyConfig(oldState, selectedKey, newKey);
		}),
		undo,
		redo,
	};
}

/**
 * 当domTree中拖拽节点调整顺序时触发
 * @param state
 * @param payload
 * @returns {{pageConfig: *}}
 */
export function onLayoutSortChange(
	state: StateType,
	payload: LayoutSortPayload,
): StateType {
	const { sortKeys, parentKey, parentPropName, dragInfo } = payload;
	const { undo, redo, pageConfig } = state;
	undo.push({ pageConfig });
	redo.length = 0;
	return {
		...state,
		pageConfig: produce(pageConfig, (oldConfigs) => {
			update(oldConfigs, getLocation(parentKey, parentPropName), () => sortKeys);
			/**
			 * dragInfo有值说明为跨组件排序，需要删除拖拽组件原先父组件中的引用
			 */
			if (dragInfo&&(dragInfo.parentKey!==parentKey||dragInfo.parentPropName!==parentPropName)) {
				const { key, parentKey, parentPropName } = dragInfo;
				update(oldConfigs, getLocation(parentKey), (childNodes) =>
					deleteChildNodesKey(childNodes, key, parentPropName),
				);
			}
		}),
		undo,
		redo,
	};
}

/**
 * 删除组件
 * @param state
 * @returns {{propsSetting: *, pageConfig: *, selectedInfo: *}}
 */
export function deleteComponent(state: StateType): StateType {
	const { undo, redo, pageConfig, selectedInfo, propsConfigSheet } = state;
	/**
	 * 未选中组件将不做任何操作
	 */
	if (!selectedInfo) {
		warn('Please select the components you want to delete');
		return state;
	}
	const { selectedKey, parentKey, parentPropName } = selectedInfo;
	undo.push({ pageConfig, selectedInfo, propsConfigSheet });
	const handleState: HandleInfoType = { pageConfig, propsConfigSheet };

	redo.length = 0;
	return {
		...state,
		...produce(handleState, (oldState) => {
			/**
			 * 如果选中的是根节点说明要删除整个页面
			 */
			if (selectedKey === ROOT) {
				oldState.pageConfig = {};
				oldState.propsConfigSheet = {};
			} else {
				// 删除选中组件在其父组件中的引用
				update(
					oldState.pageConfig,
					getLocation(parentKey),
					(childNodes) =>
						deleteChildNodesKey(childNodes, selectedKey, parentPropName),
				);
				const childNodes = oldState.pageConfig[selectedKey].childNodes;
				/**
				 * 如果childNodes有值，就遍历childNodes删除其中的子节点
				 */
				if (childNodes) {
					deleteChildNodes(oldState, childNodes);
				}
				delete oldState.pageConfig[selectedKey];
				delete oldState.propsConfigSheet[selectedKey];
			}
		}),
		selectedInfo: null,
		undo,
		redo,
	};
}

/**
 * 清除所有子节点
 * @param state
 * @returns {{undo: *, pageConfig, redo: *}}
 */

export function clearChildNodes(state: StateType): StateType {
	const { pageConfig, selectedInfo, undo, redo, propsConfigSheet } = state;
	if (!selectedInfo) {
		warn(
			'Please select the component or property you want to clear the child nodes',
		);
		return state;
	}
	const { selectedKey, propName } = selectedInfo;
	const childNodes = get(pageConfig, getLocation(selectedKey));
	if (!childNodes) return state;
	undo.push({ pageConfig, propsConfigSheet });
	const handleState: HandleInfoType = { pageConfig, propsConfigSheet };

	redo.length = 0;
	return {
		...state,
		...produce(handleState, (oldState) => {
			deleteChildNodes(oldState, childNodes, propName);
			update(
				oldState.pageConfig,
				getLocation(selectedKey),
				(childNodes) => {
					/**
					 * 如果 没有propName说明要清除组件的所有子节点
					 */
					if (!propName) {
						return undefined;
					} else {
						return restObject(childNodes, propName);
					}
				},
			);
		}),
		undo,
		redo,
	};
}
